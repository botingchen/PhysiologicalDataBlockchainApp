module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */
var Strategy = __webpack_require__(1);

/**
 * Expose `Strategy` directly from package.
 */
exports = module.exports = Strategy;

/**
 * Export constructors.
 */
exports.Strategy = Strategy;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Module dependencies.
 */
var passport = __webpack_require__(2),
    util = __webpack_require__(3),
    sigUtil = __webpack_require__(4);

/**
 * `Strategy` constructor.
 *
 * The web3 strategy works by having the user sign a message using web3 using
 * their ethereum address. We take the signed message and use `ecrecover` to
 * decode the address it was signed with. If the decoded address matches the
 * address they are trying to sign in with, we authorize the user.
 *
 * Applications must supply a `onAuth` callback which is passed the user's ETH
 * address, the message they were asked to sign, and the signed message. You
 * may optionally perform additional verification in the callback, and if the
 * user is valid then you call the calback which is passed to `onAuth` which
 * will log the user in. You must pass the user object to this callback, or
 * pass an `err` argument if the login should fail.
 *
 * Examples:
 * const onAuth = function (req, address, msg, signed, done) {
 *   User.findOne({ address }, function (err, user) {
 *     done(err, user);
 *   });
 * }
 * const web3Strategy = new Web3Strategy(onAuth);
 * passport.use(web3Strategy);
 *
 * @param {Object} options
 * @param {Function} onAuth
 * @api public
 */

var Strategy = function (_passport$Strategy) {
  _inherits(Strategy, _passport$Strategy);

  function Strategy(options, onAuth) {
    _classCallCheck(this, Strategy);

    if (typeof options == 'function') {
      onAuth = options;
      options = {};
    }
    if (!onAuth) {
      throw new TypeError('Web3Strategy requires an onAuth callback');
    }

    var _this = _possibleConstructorReturn(this, (Strategy.__proto__ || Object.getPrototypeOf(Strategy)).call(this));

    _this._onAuth = onAuth;
    _this.name = 'web3';
    return _this;
  }

  /**
   * Authenticate request based on the contents of a form submission.
   *
   * @param {Object} req
   * @api protected
   */


  _createClass(Strategy, [{
    key: 'authenticate',
    value: function authenticate(req) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var credentials = this.getCredentials(req);

      if (!credentials) {
        var err = {
          message: options.badRequestMessage || 'Missing credentials'
        };
        return this.fail(err, 400);
      }

      var address = credentials.address,
          msg = credentials.msg,
          signed = credentials.signed;


      var params = {
        data: msg,
        sig: signed
      };
      var recovered = sigUtil.recoverPersonalSignature(params);

      if (!recovered || recovered !== address) {
        var _err = {
          message: 'Invalid credentials (recovered address didnt match eth address)'
        };
        return this.fail(_err, 400);
      }

      var done = function done(err, user, info) {
        if (err) {
          return _this2.error(err);
        }
        if (!user) {
          return _this2.fail(info);
        }
        _this2.success(user, info);
      };

      try {
        var authParams = { msg: msg, signed: signed };

        this._onAuth(address, done, req, authParams);
      } catch (ex) {
        return this.error(ex);
      }
    }

    /**
     * Get the required auth params from request body, or fallback to query if
     * not provided in body, but provided in query
     * @param {Object} req
     * @return {Object}
     */

  }, {
    key: 'getCredentials',
    value: function getCredentials(req) {
      var has = function has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      var hasAll = function hasAll(obj, keys) {
        return obj && keys.every(function (k) {
          return has(obj, k);
        });
      };

      var body = req.body,
          query = req.query;

      var paramKeys = ['address', 'msg', 'signed'];

      if (hasAll(body, paramKeys)) {
        return body;
      } else if (hasAll(query, paramKeys)) {
        return query;
      }

      return null;
    }
  }]);

  return Strategy;
}(passport.Strategy);

/**
 * Expose `Strategy`.
 */


module.exports = Strategy;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("passport-strategy");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("eth-sig-util");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNmVmZGUxNmYxZDg4NGVlOTQ0OTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXNzcG9ydC1zdHJhdGVneVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldGgtc2lnLXV0aWxcIiJdLCJuYW1lcyI6WyJTdHJhdGVneSIsInJlcXVpcmUiLCJleHBvcnRzIiwibW9kdWxlIiwicGFzc3BvcnQiLCJ1dGlsIiwic2lnVXRpbCIsIm9wdGlvbnMiLCJvbkF1dGgiLCJUeXBlRXJyb3IiLCJfb25BdXRoIiwibmFtZSIsInJlcSIsImNyZWRlbnRpYWxzIiwiZ2V0Q3JlZGVudGlhbHMiLCJlcnIiLCJtZXNzYWdlIiwiYmFkUmVxdWVzdE1lc3NhZ2UiLCJmYWlsIiwiYWRkcmVzcyIsIm1zZyIsInNpZ25lZCIsInBhcmFtcyIsImRhdGEiLCJzaWciLCJyZWNvdmVyZWQiLCJyZWNvdmVyUGVyc29uYWxTaWduYXR1cmUiLCJkb25lIiwidXNlciIsImluZm8iLCJlcnJvciIsInN1Y2Nlc3MiLCJhdXRoUGFyYW1zIiwiZXgiLCJoYXMiLCJvYmoiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJoYXNBbGwiLCJrZXlzIiwiZXZlcnkiLCJrIiwiYm9keSIsInF1ZXJ5IiwicGFyYW1LZXlzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFRDs7Ozs7Ozs7O21DQU1lckIsRyxFQUFLO0FBQ2xCLFVBQU1zQixNQUFNLFNBQU5BLEdBQU0sQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOO0FBQUEsZUFBY0MsT0FBT0MsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDTCxHQUFyQyxFQUEwQ0MsR0FBMUMsQ0FBZDtBQUFBLE9BQVo7QUFDQSxVQUFNSyxTQUFTLFNBQVRBLE1BQVMsQ0FBQ04sR0FBRCxFQUFNTyxJQUFOO0FBQUEsZUFBZVAsT0FBT08sS0FBS0MsS0FBTCxDQUFXO0FBQUEsaUJBQUtULElBQUlDLEdBQUosRUFBU1MsQ0FBVCxDQUFMO0FBQUEsU0FBWCxDQUF0QjtBQUFBLE9BQWY7O0FBRmtCLFVBSVZDLElBSlUsR0FJTWpDLEdBSk4sQ0FJVmlDLElBSlU7QUFBQSxVQUlKQyxLQUpJLEdBSU1sQyxHQUpOLENBSUprQyxLQUpJOztBQUtsQixVQUFNQyxZQUFZLENBQUMsU0FBRCxFQUFZLEtBQVosRUFBbUIsUUFBbkIsQ0FBbEI7O0FBRUEsVUFBSU4sT0FBT0ksSUFBUCxFQUFhRSxTQUFiLENBQUosRUFBNkI7QUFDM0IsZUFBT0YsSUFBUDtBQUNELE9BRkQsTUFFTyxJQUFJSixPQUFPSyxLQUFQLEVBQWNDLFNBQWQsQ0FBSixFQUE4QjtBQUNuQyxlQUFPRCxLQUFQO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7Ozs7RUFqRm9CMUMsU0FBU0osUTs7QUFvRmhDOzs7OztBQUdBRyxPQUFPRCxPQUFQLEdBQWlCRixRQUFqQixDOzs7Ozs7QUMzSEEsOEM7Ozs7OztBQ0FBLGlDOzs7Ozs7QUNBQSx5QyIsImZpbGUiOiIuL2Rpc3QvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA2ZWZkZTE2ZjFkODg0ZWU5NDQ5NSIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuY29uc3QgU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3N0cmF0ZWd5LmpzJyk7XG5cblxuLyoqXG4gKiBFeHBvc2UgYFN0cmF0ZWd5YCBkaXJlY3RseSBmcm9tIHBhY2thZ2UuXG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN0cmF0ZWd5O1xuXG4vKipcbiAqIEV4cG9ydCBjb25zdHJ1Y3RvcnMuXG4gKi9cbmV4cG9ydHMuU3RyYXRlZ3kgPSBTdHJhdGVneTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIHBhc3Nwb3J0ID0gcmVxdWlyZSgncGFzc3BvcnQtc3RyYXRlZ3knKVxuICAsIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJyk7XG5cblxuLyoqXG4gKiBgU3RyYXRlZ3lgIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSB3ZWIzIHN0cmF0ZWd5IHdvcmtzIGJ5IGhhdmluZyB0aGUgdXNlciBzaWduIGEgbWVzc2FnZSB1c2luZyB3ZWIzIHVzaW5nXG4gKiB0aGVpciBldGhlcmV1bSBhZGRyZXNzLiBXZSB0YWtlIHRoZSBzaWduZWQgbWVzc2FnZSBhbmQgdXNlIGBlY3JlY292ZXJgIHRvXG4gKiBkZWNvZGUgdGhlIGFkZHJlc3MgaXQgd2FzIHNpZ25lZCB3aXRoLiBJZiB0aGUgZGVjb2RlZCBhZGRyZXNzIG1hdGNoZXMgdGhlXG4gKiBhZGRyZXNzIHRoZXkgYXJlIHRyeWluZyB0byBzaWduIGluIHdpdGgsIHdlIGF1dGhvcml6ZSB0aGUgdXNlci5cbiAqXG4gKiBBcHBsaWNhdGlvbnMgbXVzdCBzdXBwbHkgYSBgb25BdXRoYCBjYWxsYmFjayB3aGljaCBpcyBwYXNzZWQgdGhlIHVzZXIncyBFVEhcbiAqIGFkZHJlc3MsIHRoZSBtZXNzYWdlIHRoZXkgd2VyZSBhc2tlZCB0byBzaWduLCBhbmQgdGhlIHNpZ25lZCBtZXNzYWdlLiBZb3VcbiAqIG1heSBvcHRpb25hbGx5IHBlcmZvcm0gYWRkaXRpb25hbCB2ZXJpZmljYXRpb24gaW4gdGhlIGNhbGxiYWNrLCBhbmQgaWYgdGhlXG4gKiB1c2VyIGlzIHZhbGlkIHRoZW4geW91IGNhbGwgdGhlIGNhbGJhY2sgd2hpY2ggaXMgcGFzc2VkIHRvIGBvbkF1dGhgIHdoaWNoXG4gKiB3aWxsIGxvZyB0aGUgdXNlciBpbi4gWW91IG11c3QgcGFzcyB0aGUgdXNlciBvYmplY3QgdG8gdGhpcyBjYWxsYmFjaywgb3JcbiAqIHBhc3MgYW4gYGVycmAgYXJndW1lbnQgaWYgdGhlIGxvZ2luIHNob3VsZCBmYWlsLlxuICpcbiAqIEV4YW1wbGVzOlxuICogY29uc3Qgb25BdXRoID0gZnVuY3Rpb24gKHJlcSwgYWRkcmVzcywgbXNnLCBzaWduZWQsIGRvbmUpIHtcbiAqICAgVXNlci5maW5kT25lKHsgYWRkcmVzcyB9LCBmdW5jdGlvbiAoZXJyLCB1c2VyKSB7XG4gKiAgICAgZG9uZShlcnIsIHVzZXIpO1xuICogICB9KTtcbiAqIH1cbiAqIGNvbnN0IHdlYjNTdHJhdGVneSA9IG5ldyBXZWIzU3RyYXRlZ3kob25BdXRoKTtcbiAqIHBhc3Nwb3J0LnVzZSh3ZWIzU3RyYXRlZ3kpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkF1dGhcbiAqIEBhcGkgcHVibGljXG4gKi9cbmNsYXNzIFN0cmF0ZWd5IGV4dGVuZHMgcGFzc3BvcnQuU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBvbkF1dGgpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25BdXRoID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFvbkF1dGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dlYjNTdHJhdGVneSByZXF1aXJlcyBhbiBvbkF1dGggY2FsbGJhY2snKTtcbiAgICB9XG5cbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX29uQXV0aCA9IG9uQXV0aDtcbiAgICB0aGlzLm5hbWUgPSAnd2ViMyc7XG4gIH1cblxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHJlcXVlc3QgYmFzZWQgb24gdGhlIGNvbnRlbnRzIG9mIGEgZm9ybSBzdWJtaXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxXG4gICAqIEBhcGkgcHJvdGVjdGVkXG4gICAqL1xuICBhdXRoZW50aWNhdGUocmVxLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuZ2V0Q3JlZGVudGlhbHMocmVxKTtcblxuICAgIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5iYWRSZXF1ZXN0TWVzc2FnZSB8fCAnTWlzc2luZyBjcmVkZW50aWFscydcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5mYWlsKGVyciwgNDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGFkZHJlc3MsIG1zZywgc2lnbmVkIH0gPSBjcmVkZW50aWFscztcblxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGRhdGE6IG1zZyxcbiAgICAgIHNpZzogc2lnbmVkXG4gICAgfTtcbiAgICBjb25zdCByZWNvdmVyZWQgPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShwYXJhbXMpO1xuXG4gICAgaWYgKCFyZWNvdmVyZWQgfHwgcmVjb3ZlcmVkICE9PSBhZGRyZXNzKSB7XG4gICAgICBjb25zdCBlcnIgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGNyZWRlbnRpYWxzIChyZWNvdmVyZWQgYWRkcmVzcyBkaWRudCBtYXRjaCBldGggYWRkcmVzcyknXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbChlcnIsIDQwMCk7XG4gICAgfVxuXG4gICAgY29uc3QgZG9uZSA9IChlcnIsIHVzZXIsIGluZm8pID0+IHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIHRoaXMuZXJyb3IoZXJyKTsgfVxuICAgICAgaWYgKCF1c2VyKSB7IHJldHVybiB0aGlzLmZhaWwoaW5mbyk7IH1cbiAgICAgIHRoaXMuc3VjY2Vzcyh1c2VyLCBpbmZvKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYXV0aFBhcmFtcyA9IHsgbXNnLCBzaWduZWQgfTtcblxuICAgICAgdGhpcy5fb25BdXRoKGFkZHJlc3MsIGRvbmUsIHJlcSwgYXV0aFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXF1aXJlZCBhdXRoIHBhcmFtcyBmcm9tIHJlcXVlc3QgYm9keSwgb3IgZmFsbGJhY2sgdG8gcXVlcnkgaWZcbiAgICogbm90IHByb3ZpZGVkIGluIGJvZHksIGJ1dCBwcm92aWRlZCBpbiBxdWVyeVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldENyZWRlbnRpYWxzKHJlcSkge1xuICAgIGNvbnN0IGhhcyA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICBjb25zdCBoYXNBbGwgPSAob2JqLCBrZXlzKSA9PiBvYmogJiYga2V5cy5ldmVyeShrID0+IGhhcyhvYmosIGspKTtcblxuICAgIGNvbnN0IHsgYm9keSwgcXVlcnkgfSA9IHJlcTtcbiAgICBjb25zdCBwYXJhbUtleXMgPSBbJ2FkZHJlc3MnLCAnbXNnJywgJ3NpZ25lZCddO1xuXG4gICAgaWYgKGhhc0FsbChib2R5LCBwYXJhbUtleXMpKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9IGVsc2UgaWYgKGhhc0FsbChxdWVyeSwgcGFyYW1LZXlzKSkge1xuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIGBTdHJhdGVneWAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gU3RyYXRlZ3k7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RyYXRlZ3kuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXNzcG9ydC1zdHJhdGVneVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInBhc3Nwb3J0LXN0cmF0ZWd5XCJcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInV0aWxcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldGgtc2lnLXV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJldGgtc2lnLXV0aWxcIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9